import pygame
import sys
import random
import math
import numpy as np

# ============================================================
# GLOBAL CONFIGURATION
# ============================================================

WINDOW_SIZE = 900
GRID_SIZE = 30
CELL = WINDOW_SIZE // GRID_SIZE
FPS = 30

# Synthetic data density (stand-ins for satellite-derived layers)
NUM_WATER = 4
NUM_VILLAGES = 6
NUM_HERD_PRIORS = 5   # historical / recent presence

# ============================================================
# COLOR PALETTE (Semantic)
# ============================================================

GRASS = (60, 175, 60)           # baseline land
WATER = (40, 150, 255)          # surface water
VILLAGE = (140, 90, 40)         # settlements
HERD_PRIOR = (160, 70, 200)     # known / recent herd presence

CONF_STRONG = (200, 200, 0)
CONF_PROB = (255, 235, 120)
CONF_POSSIBLE = (255, 255, 190)

BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
PANEL_BG = (20, 20, 20, 220)

# ============================================================
# INITIALIZE PYGAME
# ============================================================

pygame.init()
screen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))
pygame.display.set_caption("Probabilistic Cattle Movement Forecasting Prototype")

font = pygame.font.SysFont("Arial", 16)
big_font = pygame.font.SysFont("Arial", 22)

# ============================================================
# UI BUTTON
# ============================================================

class Button:
    def __init__(self, label, x, y, w, h):
        self.rect = pygame.Rect(x, y, w, h)
        self.label = label

    def draw(self):
        pygame.draw.rect(screen, BLACK, self.rect, border_radius=6)
        txt = font.render(self.label, True, WHITE)
        screen.blit(txt, txt.get_rect(center=self.rect.center))

    def clicked(self, event):
        return event.type == pygame.MOUSEBUTTONDOWN and self.rect.collidepoint(event.pos)

# ============================================================
# SYNTHETIC GEOSPATIAL INPUT GENERATION
# ============================================================

def generate_synthetic_geospatial_inputs():
    """
    Stand-in for open-source satellite and geospatial layers.
    In a real system, these would be derived from NDVI, OpenStreetMap,
    hydrology datasets, etc.
    """

    water_sources = [(random.randrange(GRID_SIZE), random.randrange(GRID_SIZE)) for _ in range(NUM_WATER)]
    villages = [(random.randrange(GRID_SIZE), random.randrange(GRID_SIZE)) for _ in range(NUM_VILLAGES)]
    herd_priors = [(random.randrange(GRID_SIZE), random.randrange(GRID_SIZE)) for _ in range(NUM_HERD_PRIORS)]

    # Vegetation suitability layer (proxy for NDVI)
    vegetation = np.random.uniform(0.4, 1.0, (GRID_SIZE, GRID_SIZE))

    return water_sources, villages, herd_priors, vegetation

# ============================================================
# MOVEMENT SUITABILITY MODEL (CORE AI LOGIC)
# ============================================================

def compute_movement_suitability(
    water_sources,
    villages,
    herd_priors,
    vegetation,
    previous_surface=None
):
    """
    Computes a probabilistic movement suitability surface.
    This is NOT a deterministic prediction â€” it represents
    relative likelihood under uncertainty.
    """

    surface = np.zeros((GRID_SIZE, GRID_SIZE))

    for x in range(GRID_SIZE):
        for y in range(GRID_SIZE):

            score = 0.0

            # Water attraction
            for wx, wy in water_sources:
                score += max(0, 6 - math.dist((x,y),(wx,wy)))

            # Settlement interaction
            for vx, vy in villages:
                score += max(0, 4 - math.dist((x,y),(vx,vy)))

            # Herd inertia (temporal continuity)
            for hx, hy in herd_priors:
                score += max(0, 5 - math.dist((x,y),(hx,hy)))

            # Vegetation productivity (satellite proxy)
            score *= vegetation[x, y]

            # Temporal smoothing (weak prior from previous timestep)
            if previous_surface is not None:
                score += 0.4 * previous_surface[x, y]

            surface[x, y] = score

    # Normalize per timestep (relative confidence, not absolute)
    flat = surface.flatten()
    t_high, t_mid, t_low = np.percentile(flat, [70, 40, 15])

    confidence = np.zeros_like(surface, dtype=int)

    for x in range(GRID_SIZE):
        for y in range(GRID_SIZE):
            if surface[x,y] >= t_high:
                confidence[x,y] = 3
            elif surface[x,y] >= t_mid:
                confidence[x,y] = 2
            elif surface[x,y] >= t_low:
                confidence[x,y] = 1

    return confidence, surface

# ============================================================
# RENDER MAP
# ============================================================

def draw_map(water, villages, herds, vegetation, confidence=None):
    screen.fill(GRASS)

    # AI prediction overlay
    if confidence is not None:
        for x in range(GRID_SIZE):
            for y in range(GRID_SIZE):
                c = confidence[x,y]
                if c == 3:
                    col = CONF_STRONG
                elif c == 2:
                    col = CONF_PROB
                elif c == 1:
                    col = CONF_POSSIBLE
                else:
                    continue
                pygame.draw.rect(screen, col, (x*CELL, y*CELL, CELL, CELL))

    # Water
    for x,y in water:
        pygame.draw.rect(screen, WATER, (x*CELL, y*CELL, CELL, CELL))

    # Villages
    for x,y in villages:
        pygame.draw.rect(screen, VILLAGE, (x*CELL+6, y*CELL+10, CELL-12, CELL-12))

    # Herd priors
    for x,y in herds:
        pygame.draw.circle(screen, HERD_PRIOR, (x*CELL+CELL//2, y*CELL+CELL//2), CELL//3)

# ============================================================
# LEGEND OVERLAY
# ============================================================

def draw_legend():
    panel = pygame.Surface((560, 420), pygame.SRCALPHA)
    panel.fill(PANEL_BG)
    screen.blit(panel, (170, 220))

    screen.blit(big_font.render("Map Key & AI Confidence Legend", True, WHITE), (200, 240))

    lines = [
        ("Blue Cells", "Surface Water (satellite proxy)"),
        ("Brown Blocks", "Villages / settlements"),
        ("Purple Circles", "Recent / historical herd presence"),
        ("", ""),
        ("Dark Yellow", "Strong likelihood (relative, batch-based)"),
        ("Yellow", "Probable"),
        ("Light Yellow", "Possible"),
        ("Green", "Low likelihood / uncertainty")
    ]

    y = 290
    for a,b in lines:
        if a:
            screen.blit(font.render(a+" :", True, WHITE), (200, y))
            screen.blit(font.render(b, True, WHITE), (420, y))
        y += 32

    close = pygame.Rect(670, 230, 30, 30)
    pygame.draw.rect(screen, (180,50,50), close)
    screen.blit(font.render("X", True, WHITE), (680, 232))
    return close

# ============================================================
# MAIN LOOP
# ============================================================

def main():
    clock = pygame.time.Clock()

    show_ai = False
    show_legend = False

    timestep = 0
    prev_surface = None

    btn_ai = Button("Toggle AI", 20, 20, 120, 40)
    btn_key = Button("Show Key", WINDOW_SIZE//2 - 70, 20, 140, 40)
    btn_next = Button("Next Timestep", WINDOW_SIZE - 190, 20, 170, 40)

    water, villages, herds, vegetation = generate_synthetic_geospatial_inputs()
    confidence, prev_surface = compute_movement_suitability(
        water, villages, herds, vegetation
    )

    running = True
    while running:
        for e in pygame.event.get():
            if e.type == pygame.QUIT:
                running = False

            if btn_ai.clicked(e):
                show_ai = not show_ai

            if btn_key.clicked(e):
                show_legend = True

            if btn_next.clicked(e):
                timestep += 1
                # herd priors drift toward high-suitability areas
                herds = [(random.randrange(GRID_SIZE), random.randrange(GRID_SIZE)) for _ in herds]
                confidence, prev_surface = compute_movement_suitability(
                    water, villages, herds, vegetation, prev_surface
                )

        draw_map(water, villages, herds, vegetation, confidence if show_ai else None)

        btn_ai.draw()
        btn_key.draw()
        btn_next.draw()

        if show_legend:
            close = draw_legend()
            if pygame.mouse.get_pressed()[0] and close.collidepoint(pygame.mouse.get_pos()):
                show_legend = False

        pygame.display.flip()
        clock.tick(FPS)

    pygame.quit()
    sys.exit()

# ============================================================
if __name__ == "__main__":
    main()
